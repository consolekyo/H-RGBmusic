C51 COMPILER V9.01   TCS                                                                   05/25/2018 23:10:51 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE TCS
OBJECT MODULE PLACED IN .\out\tcs.obj
COMPILER INVOKED BY: D:\programfiles-install\keilMDK523\C51\BIN\C51.EXE files\tcs.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG
                    - OBJECTEXTEND PRINT(.\tcs.lst) OBJECT(.\out\tcs.obj)

line level    source

   1          //#include <reg52.h>
   2          #include "60s2.h"
   3          #define uchar unsigned char
   4          #define uint  unsigned int
   5          //==============LCD1602接口连接方法=====================
   6          /*-----------------------------------------------------
   7                 |DB0-----P0.0 | DB4-----P0.4 | RW-------P2.3    |
   8                 |DB1-----P0.1 | DB5-----P0.5 | RS-------P2.4    |
   9                 |DB2-----P0.2 | DB6-----P0.6 | E--------P2.2    |
  10                 |DB3-----P0.3 | DB7-----P0.7 | 
  11              ---------------------------------------------------*/
  12          //================================================*/              
  13          #define LCM_Data     P0    //LCD1602数据接口
  14          #define Busy         0x80   //用于检测LCM状态字中的Busy标识
  15          sbit    LCM_RW     = P2^5;  //读写控制输入端，LCD1602的第五脚
  16          sbit    LCM_RS     = P2^6;  //寄存器选择输入端，LCD1602的第四脚
  17          sbit    LCM_E      = P2^7;  //使能信号输入端,LCD1602的第6脚
  18          
  19          //=================颜色传感模块连接=====================
  20          /*-----------------------------------------------------
  21                 |EO-----GND
  22                 |S0-----VCC | S2-----P2.0 | OUT-------P3.5 
  23                 |S1-----VCC | S3-----P2.1 | 
  24            ---------------------------------------------------*/
  25          sbit    tcs230_s2=P2^0;//TCS230 S2接单片机P2.0
  26          sbit    tcs230_s3=P2^1;//TCS230 S3接单片机P2.1
  27          sbit    tcs230_en=P3^0; //TCS230 EN(E0)接GND
  28          //**************函数声明***************************************
  29          void    WriteDataLCM            (uchar WDLCM);//LCD模块写数据
  30          void    WriteCommandLCM (uchar WCLCM,BuysC); //LCD模块写指令
  31          uchar   ReadStatusLCM(void);//读LCD模块的忙标
  32          void    DisplayOneChar(uchar X,uchar Y,uchar ASCII);//在第X+1行的第Y+1位置显示一个字符
  33          void    LCMInit(void);//LCD初始
  34          void    DelayMs(uint Ms);//1MS基准延时程序
  35          void    baipingheng();//白平衡子程序
  36          void    celiang();//实际颜色程序
  37          uint    ryz,gyz,byz;//分别定义红色因子 绿色因子 蓝色因子
  38          uint    rb,gb,bb;//RGB值
  39          uchar   tab1[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
  40          
  41          //******************************************************
  42          //求RGB
  43          void   celiang()
  44          {
  45   1           //*********求R值************************************
  46   1           TH0=0x00;  //TH0=(65536-10000)/256;
  47   1               TL0=0x00;  //TL0=(65536-10000)/256;
  48   1           TH1=0;
  49   1           TL1=0;
  50   1           tcs230_s2=0;
  51   1           tcs230_s3=0;//选择红色滤光器
  52   1           tcs230_en=0;
  53   1           TR0=1;//10毫秒开始计时
  54   1           TR1=1;//开始计数
C51 COMPILER V9.01   TCS                                                                   05/25/2018 23:10:51 PAGE 2   

  55   1           while(TF0==0);//等待定时器溢出
  56   1           TF0=0;//清楚定时器0溢出标志
  57   1           TR0=0;//关闭定时0
  58   1           TR1=0;
  59   1           rb=(unsigned long)(TH1*256+TL1)*255/ryz;
  60   1           if(rb>255)rb=255;//判断RGB值是否合法
  61   1           //********=255***求B值**************************************
  62   1           TH0=0x00;  //TH0=(65536-10000)/256;
  63   1               TL0=0x00;  //TL0=(65536-10000)/256;
  64   1           TH1=0;
  65   1           TL1=0;
  66   1           tcs230_s2=0;
  67   1           tcs230_s3=1;//选择蓝色滤光器
  68   1           TR0=1;//10毫秒开始计时
  69   1           TR1=1;//开始计数
  70   1           while(TF0==0);//等待定时器溢出
  71   1           TF0=0;//清楚定时器0溢出标志
  72   1           TR0=0;//关闭定时0
  73   1           TR1=0;
  74   1           bb=(unsigned long)(TH1*256+TL1)*255/byz;
  75   1           if(bb>255)bb=255;//判断RGB值是否合法     
  76   1           //***********求G值**************************************   
  77   1           TH0=0x00;  //TH0=(65536-10000)/256;
  78   1               TL0=0x00;  //TL0=(65536-10000)/256;
  79   1           TH1=0;
  80   1           TL1=0;
  81   1           tcs230_s2=1;
  82   1           tcs230_s3=1;//选择绿色滤光器
  83   1           TR0=1;//10毫秒开始计时
  84   1           TR1=1;//开始计数
  85   1           while(TF0==0);//等待定时器溢出
  86   1           TF0=0;//清楚定时器0溢出标志
  87   1           TR0=0;//关闭定时0
  88   1           TR1=0;
  89   1           tcs230_en=1;
  90   1           gb=(unsigned long)(TH1*256+TL1)*255/gyz;
  91   1           if(gb>255)gb=255;//判断RGB值是否合法  
  92   1      }
  93          //******************************************************
  94          //白平衡子程序
  95          void    baipingheng()
  96          {
  97   1           //**************求取红色因子***********************
  98   1           TH0=0x00;  //TH0=(65536-10000)/256;
  99   1               TL0=0x00;  //TL0=(65536-10000)/256;
 100   1           TH1=0;
 101   1           TL1=0;
 102   1           tcs230_s2=0;
 103   1           tcs230_s3=0;//选择红色滤光器
 104   1           tcs230_en=0;
 105   1           TR0=1;//10毫秒开始计时
 106   1           TR1=1;//开始计数
 107   1           while(TF0==0);//等待定时器溢出
 108   1           TF0=0;//清楚定时器0溢出标志
 109   1           TR0=0;//关闭定时0
 110   1           TR1=0;
 111   1           ryz=255/(TH1*256+TL1);//其实这里的比例因子应该为255/(TH1*256+TL1)
 112   1           //**************求取蓝色因子***********************
 113   1           TH0=0x00;  //TH0=(65536-10000)/256;
 114   1               TL0=0x00;  //TL0=(65536-10000)/256;
 115   1           TH1=0;
 116   1           TL1=0;
C51 COMPILER V9.01   TCS                                                                   05/25/2018 23:10:51 PAGE 3   

 117   1           tcs230_s2=0;
 118   1           tcs230_s3=1;//选择蓝色滤光器
 119   1           TR0=1;//10毫秒开始计时
 120   1           TR1=1;//开始计数
 121   1           while(TF0==0);//等待定时器溢出
 122   1           TF0=0;//清楚定时器0溢出标志
 123   1           TR0=0;//关闭定时0
 124   1           TR1=0;
 125   1           byz=255/(TH1*256+TL1);//其实这里的比例因子应该为255/(TH1*256+TL1)
 126   1           //**************求绿红色因子***********************
 127   1           TH0=0x00;  //TH0=(65536-10000)/256;
 128   1               TL0=0x00;  //TL0=(65536-10000)/256;
 129   1           TH1=0;
 130   1           TL1=0;
 131   1           tcs230_s2=1;
 132   1           tcs230_s3=1;//选择绿色滤光器
 133   1           TR0=1;//10毫秒开始计时
 134   1           TR1=1;//开始计数
 135   1           while(TF0==0);//等待定时器溢出
 136   1           TF0=0;//清楚定时器0溢出标志
 137   1           TR0=0;//关闭定时0
 138   1           TR1=0;
 139   1           tcs230_en=1;
 140   1           gyz=255/(TH1*256+TL1);//其实这里的比例因子应该为255/(TH1*256+TL1)
 141   1      }
 142          /*======================================================================
 143           LCM初始化
 144          ======================================================================*/
 145          void LCMInit(void) 
 146          {
 147   1       LCM_Data = 0;
 148   1       WriteCommandLCM(0x38,0); //三次显示模式设置，不检测忙信号
 149   1       DelayMs(5);
 150   1       WriteCommandLCM(0x38,0);
 151   1       DelayMs(5);
 152   1       WriteCommandLCM(0x38,0);
 153   1       DelayMs(5);
 154   1       WriteCommandLCM(0x38,1); //显示模式设置,开始要求每次检测忙信号
 155   1       WriteCommandLCM(0x08,1); //关闭显示
 156   1       WriteCommandLCM(0x01,1); //显示清屏
 157   1       WriteCommandLCM(0x06,1); // 显示光标移动设置
 158   1       WriteCommandLCM(0x0C,1); // 显示开及光标设置
 159   1       DelayMs(100);
 160   1      }
 161          //==============================LCD1602显示子程序================================================
 162          // 写数据函数: E =高脉冲 RS=1 RW=0
 163          //======================================================================*/
 164          void WriteDataLCM(uchar WDLCM)
 165          {
 166   1       ReadStatusLCM(); //检测忙
 167   1       LCM_Data = WDLCM;
 168   1       LCM_RS = 1;
 169   1       LCM_RW = 0;
 170   1       LCM_E = 0; //若晶振速度太高可以在这后加小的延时
 171   1       LCM_E = 0; //延时
 172   1       LCM_E = 1;
 173   1      }
 174          /*====================================================================
 175            写指令函数: E=高脉冲 RS=0 RW=0
 176          ======================================================================*/
 177          void WriteCommandLCM(uchar WCLCM,BuysC) //BuysC为0时忽略忙检测
 178          {
C51 COMPILER V9.01   TCS                                                                   05/25/2018 23:10:51 PAGE 4   

 179   1       if (BuysC) ReadStatusLCM(); //根据需要检测忙
 180   1       LCM_Data = WCLCM;
 181   1       LCM_RS = 0;
 182   1       LCM_RW = 0;
 183   1       LCM_E = 0;
 184   1       LCM_E = 0;
 185   1       LCM_E = 1;
 186   1      }
 187          /*====================================================================
 188            正常读写操作之前必须检测LCD控制器状态:E=1 RS=0 RW=1;
 189            DB7: 0 LCD控制器空闲，1 LCD控制器忙。
 190            读状态
 191          ======================================================================*/
 192          uchar ReadStatusLCM(void)
 193          {
 194   1       LCM_Data = 0xFF;
 195   1       LCM_RS = 0;
 196   1       LCM_RW = 1;
 197   1       LCM_E = 0;
 198   1       LCM_E = 0;
 199   1       LCM_E = 1;
 200   1       while (LCM_Data & Busy); //检测忙信号  
 201   1       return(LCM_Data);
 202   1      }
 203          /*======================================================================
 204          功 能:     在1602 指定位置显示一个字符:第一行位置0~15,第二行16~31
 205          说 明:     第 X 行,第 y 列  注意:字符串不能长于16个字符
 206          ======================================================================*/
 207          void DisplayOneChar( uchar X, uchar Y, uchar ASCII)
 208          {
 209   1        X &= 0x1;
 210   1        Y &= 0xF; //限制Y不能大于15，X不能大于1
 211   1        if (X) Y |= 0x40; //当要显示第二行时地址码+0x40;
 212   1        Y |= 0x80; // 算出指令码
 213   1        WriteCommandLCM(Y, 0); //这里不检测忙信号，发送地址码
 214   1        WriteDataLCM(ASCII);
 215   1      }
 216          /*====================================================================
 217            设定延时时间:x*1ms
 218          ====================================================================*/
 219          void DelayMs(uint Ms)
 220          {
 221   1        uint i,TempCyc;
 222   1        for(i=0;i<Ms;i++)
 223   1        {
 224   2          TempCyc = 250;
 225   2          while(TempCyc--);
 226   2        }
 227   1      }
 228                   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    701    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     28       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
